================================================================================
MINI COMPILER - FORMAL GRAMMAR SPECIFICATION (WITH FUNCTIONS)
================================================================================

LEXICAL TOKENS:
--------------
Keywords: int, float, char, if, elif, else, loop, from, to, step, print, input, return, func
Operators: +, -, *, /, %, =, ==, !=, <, >, <=, >=, &&, ||, !
Delimiters: (, ), {, }, ;, ,
Literals: INTEGER_LITERAL, FLOAT_LITERAL, CHAR_LITERAL
Identifiers: [a-zA-Z_][a-zA-Z0-9_]*

GRAMMAR RULES (BNF):
-------------------

Program → FunctionList StmtList

FunctionList → FunctionDecl FunctionList
             | ε

FunctionDecl → 'func' Type IDENTIFIER '(' ParamList ')' Block

ParamList → Param ParamListTail
          | ε

ParamListTail → ',' Param ParamListTail
              | ε

Param → Type IDENTIFIER

StmtList → Stmt StmtList
         | ε

Stmt → DeclStmt
     | AssignStmt
     | IfStmt
     | LoopStmt
     | PrintStmt
     | InputStmt
     | ReturnStmt
     | Block

Block → '{' StmtList '}'

DeclStmt → Type IDENTIFIER ';'
         | Type IDENTIFIER '=' Expr ';'

Type → 'int'
     | 'float'
     | 'char'

AssignStmt → IDENTIFIER '=' Expr ';'

IfStmt → 'if' '(' Condition ')' Block ElifList ElsePart

ElifList → 'elif' '(' Condition ')' Block ElifList
         | ε

ElsePart → 'else' Block
         | ε

LoopStmt → 'loop' 'from' IDENTIFIER '=' Expr 'to' Expr 'step' Expr Block
         | 'loop' 'from' IDENTIFIER '=' Expr 'to' Expr Block
         | 'loop' 'from' IDENTIFIER 'to' Expr 'step' Expr Block
         | 'loop' 'from' IDENTIFIER 'to' Expr Block

PrintStmt → 'print' Expr ';'

InputStmt → 'input' IDENTIFIER ';'

ReturnStmt → 'return' Expr ';'
           | 'return' ';'

Condition → Expr RelOp Expr
          | Condition LogicOp Condition
          | '!' Condition
          | '(' Condition ')'

Expr → Term ExprPrime

ExprPrime → '+' Term ExprPrime
          | '-' Term ExprPrime
          | ε

Term → Factor TermPrime

TermPrime → '*' Factor TermPrime
          | '/' Factor TermPrime
          | '%' Factor TermPrime
          | ε

Factor → IDENTIFIER
       | FunctionCall
       | INTEGER_LITERAL
       | FLOAT_LITERAL
       | CHAR_LITERAL
       | '(' Expr ')'
       | '-' Factor

FunctionCall → IDENTIFIER '(' ArgList ')'

ArgList → Expr ArgListTail
        | ε

ArgListTail → ',' Expr ArgListTail
            | ε

RelOp → '==' | '!=' | '<' | '>' | '<=' | '>='

LogicOp → '&&' | '||'

================================================================================
FUNCTION SEMANTICS:
------------------
1. Functions must be declared before use
2. Function calls must match parameter count and types
3. Return type must match function declaration
4. Recursion is supported
5. Functions have their own scope
6. Parameters are passed by value

EXAMPLE FUNCTION:
func int factorial(int n) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

int result;
result = factorial(5);
print result;

================================================================================
TYPE COERCION RULES:
-------------------
1. int + int → int
2. float + float → float
3. int + float → float (int promoted to float)
4. float + int → float (int promoted to float)
5. char in arithmetic → promoted to int
6. Assignment: int = float → ERROR (narrowing not allowed)
7. Assignment: float = int → OK (widening allowed)

================================================================================
OPERATOR PRECEDENCE (Highest to Lowest):
----------------------------------------
1. Unary: -, !
2. Multiplicative: *, /, %
3. Additive: +, -
4. Relational: <, >, <=, >=
5. Equality: ==, !=
6. Logical AND: &&
7. Logical OR: ||
8. Assignment: =

================================================================================
